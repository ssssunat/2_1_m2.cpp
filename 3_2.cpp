Даны неотрицательные целые числа n,k и массив целых чисел из [0..10^9] размера n.
Требуется найти k-ю порядковую статистику. 
т.е. напечатать число, которое бы стояло на позиции с индексом k (0..n-1) в отсортированном массиве. Напишите нерекурсивный алгоритм.
Требования к дополнительной памяти: O(n). Требуемое среднее время работы: O(n).
Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.
Описание для случая прохода от начала массива к концу:
Выбирается опорный элемент. Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного. 
Затем располагаются элементы, строго бОльшие опорного. В конце массива лежат нерассмотренные элементы. Последним элементом лежит опорный.
Итератор (индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма. Рассматривается элемент, на который указывает j. Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.
3_2. Реализуйте стратегию выбора опорного элемента “медиана трёх”. 
Функцию Partition реализуйте методом прохода двумя итераторами от конца массива к началу.



#include <iostream>


int *middleOfThree(int *a, int *b, int *c) {
    if (*a < *b) {
        if (*b < *c) {
            return b;
        } else if (*a < *c) {
            return c;
        } else {
            return a;
        }
    } else {
        if (*a < *c) {
            return a;
        } else if (*b < *c) {
            return c;
        } else {
            return b;
        }
    }
}

int *partion(int *pivot, int *begin, int *end) {
    std::swap(*begin, *pivot);

    int *i = end;
    int *j = end;

    while (j > begin) {
        if (*j > *begin) {
            std::swap(*i, *j);
            --i;
        }

        --j;
    }

    std::swap(*i, *begin);

    return i;
}

int k_Statistic(int k, int *begin, int *end) {
    while (true) {
        int *pivot = middleOfThree(begin, end - 1, (begin + (end - 1 - begin) / 2));
        int *m = partion(pivot, begin, end);

        if (m - begin == k) {
            return *m;
        } else if (m - begin > k) {
            end = m - 1;
        } else {
            k -= (m - begin) + 1;
            begin = m + 1;
        }
    }
}

int main() {
    int n = 0;
    int k = 0;
    std::cin >> n >> k;

    int *begin = new int[n];

    for (int i = 0; i < n; ++i) {
        std::cin >> begin[i];
    }

    std::cout << k_Statistic(k, begin, begin + n - 1) << '\n';

    delete[] begin;

    return 0;
}
